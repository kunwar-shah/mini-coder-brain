#!/usr/bin/env bash
set -u

# Session End Hook - Captures conversation when user explicitly ends session
# Runs when user closes conversation or exits Claude Code
# Philosophy: Graceful degradation - prefer fallback over failure

ROOT="${CLAUDE_PROJECT_DIR:-.}"
LIB="$ROOT/.claude/hooks/lib/hook-patterns.sh"

# Source bulletproof patterns library
source "$LIB"

# Setup safe exit trap (CRITICAL: ensures we always exit 0)
setup_safe_exit_trap

MB="$ROOT/.claude/memory"

# Read hook input (SAFE: fallback if empty)
payload=$(read_stdin_safe "{}")

# Extract fields (SAFE: no jq dependency)
tp=$(extract_json_field "$payload" "transcript_path" "")
reason=$(extract_json_field "$payload" "reason" "user_exit")

# Timestamp
stamp="sessionend-$(date +%Y%m%d-%H%M%S)"
dt=$(date --iso-8601=seconds)

# Ensure directories (SAFE: never crash)
ensure_dir "$MB/conversations"

# Create session end summary
summary_file="$MB/conversations/$stamp.summary.md"

cat > "$summary_file" <<EOF
# Session End Summary — $stamp

**Timestamp**: $dt
**Reason**: $reason
**Type**: User-initiated session close

## Session Accomplishments
$(tail -20 "$MB/progress.md" 2>/dev/null | grep -E "✅|🔄|⏳" | tail -10 || echo "- Check progress.md for session completions")

## Key Files Modified
$(find "$ROOT" -name "*.md" -o -name "*.sh" -o -name "*.js" -o -name "*.ts" -newermt "1 hour ago" 2>/dev/null | head -15 | sed 's|'$ROOT'/||' | sed 's/^/- /' || echo "- No recent file modifications detected")

## Technical Context
$(tail -5 "$MB/decisionLog.md" 2>/dev/null | grep -E "Decision|ADR" | tail -3 || echo "- Check decisionLog.md for decisions")

## Active Focus (Next Session)
$(head -30 "$MB/activeContext.md" 2>/dev/null | grep -A 3 "🎯 Current Focus" | tail -3 || echo "- Check activeContext.md")

## Next Steps
$(grep -A 5 "🚀 Next Priorities" "$MB/activeContext.md" 2>/dev/null | tail -5 || echo "- Continue current development work")

---
**Auto-generated by Session End Hook**
EOF

# Copy transcript if available
if [ -n "$tp" ] && [ -f "$tp" ]; then
  raw_file="$MB/conversations/$stamp.transcript.jsonl"
  cp "$tp" "$raw_file" 2>/dev/null || true

  # Create response analysis
  response_log="$MB/conversations/$stamp.responses.md"

  cat > "$response_log" <<EOF
# Session Response Log — $stamp

## Tool Usage Summary
$(grep -o '"tool_name":"[^"]*"' "$tp" 2>/dev/null | sort | uniq -c | sort -nr | head -10 || echo "No tool usage found")

## File Operations
$(grep -o '"file_path":"[^"]*"' "$tp" 2>/dev/null | head -20 | sed 's/.*://; s/"//g; s/^/- /' || echo "No file operations detected")

## Response Count
**Total Responses**: $(grep -c '"type":"assistant_message"' "$tp" 2>/dev/null || echo "Unknown")

---
**Extracted from**: $(basename "$tp")
EOF
fi

# Add session end note to activeContext
{
  echo ""
  echo "## 📊 Session End @ $(date '+%Y-%m-%d %H:%M UTC')"
  echo "- **Reason**: $reason"
  echo "- **Summary**: $stamp.summary.md"
  echo "- **Status**: Ready for next session"
} >> "$MB/activeContext.md" || true

# === METRICS COLLECTION (v2.1+) ===
# Finalize session metrics
if [ -f "$ROOT/.claude/hooks/metrics-collector.sh" ]; then
  # Calculate session duration (from context-loaded.flag timestamp)
  context_flag="$ROOT/.claude/tmp/context-loaded.flag"
  if [ -f "$context_flag" ]; then
    session_start=$(tail -1 "$context_flag" 2>/dev/null | date -f - +%s 2>/dev/null || date +%s)
    session_end=$(date +%s)
    duration_minutes=$(( (session_end - session_start) / 60 ))

    # Record session end metrics
    "$ROOT/.claude/hooks/metrics-collector.sh" finalize "$duration_minutes" 2>/dev/null || true
  fi

  # Cleanup old metrics
  "$ROOT/.claude/hooks/metrics-collector.sh" cleanup 2>/dev/null || true
fi

# CRITICAL: Always exit 0, never crash the session
safe_exit
